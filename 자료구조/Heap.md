## Heap이란

- 완전 이진 트리의 일종
    - 자식이 2개
    - 왼쪽부터 빈곳없이 차례대로 채워진 완전 이진 트리 트리
        <details>
        <summary>full binary tree vs complete bianry tree</summary>
        <div markdown="1">
        <img src="../images/자료구조/Heap - 완전 이진 트리.png" alt="완전 이진 트리" width=180/>
        </div>
        </details>            
- 우선순위 큐를 위해 만들어짐 ⇒ 여러개의 값들 중에서 최대값이나 최소값을 찾을 수 있음
    - 이진 탐색 트리와 다르게 중복된 값 허용
- 부모 노드의 키 값은 항상 자식노드보다 작음

## Heap의 구현

- 배열을 통해 구현할 수 있음
    - 완전 이진 트리이기 때문에 배열로 쉽게 구현할 수 있음.
- 계산을 쉽게 하기 위해 인덱스 1부터 시작
    - 부모 - 자식 접근 식이 더 간단해짐
- 왼쪽 자식 인덱스 = 부모 인덱스 x 2
- 오른쪽 자식 인덱스 = 부모 인덱스 x 2 + 1
- 부모의 인덱스 = 자식의 인덱스 / 2

## Heap의 삽입

1. **가장 마지막**에 노드를 삽입함
2. **부모로 거슬러 올라가면서** 자기보다 더 큰 값을 교환하는 것을 반복 == heapify 알고리즘

## Heap의 삭제

1. **루트 노드가 삭제됨**
2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져옴
3. **자식 노드로 내려가면서, 자식 노드 중 큰 쪽과 비교해** 자기보다 더 큰값과 교환하는 것을 반복 == heapify 알고리즘

## Heap 정렬

- 정렬해야되는 요소로 max heap (내림차순 정렬) or min heap (오름차순 정렬)을 구현한다.
    1. n개의 요소를 차례대로 heappush 한다. ⇒ $nlog n$
    2. heap에서 n번 삭제한다. ⇒ $nlog n$

## 시간복잡도

- 트리를 사용했기 때문에,삽입, 삭제 모두 $logn$
    - 트리의 깊이에 비례
- 완전 이진 트리이기 때문에 깊이가 한쪽으로만 치우쳐지지 않고 일정하게($logn$)으로 유지 가능